# Spring Boot 백엔드 개발 공통 규칙

## Exception 처리
- 모든 예외는 CustomException 사용
- 패턴: `repository.findByXxx().orElseThrow(() -> new CustomException(HttpStatus, "error.code", "메시지"))`
- 에러 코드 형식: `{project}.{module}.{fail/success}.{detail}`

## 인증 처리
- @AuthenticationPrincipal UserPrincipal userPrincipal 사용
- Service 호출 시: `userPrincipal.getAuthDto()` 전달
- 예시: `return service.method(userPrincipal.getAuthDto(), request);`

## Controller 규칙
- @RequestMapping에 접두사 사용 금지 (전체 검색 지원)
- 전체 경로는 @PostMapping, @GetMapping 등에 명시
- 예시: `@PostMapping("/api/v1/client/resource")`

## Request DTO
- 모든 Request DTO는 toEntity() 메서드 필수 구현
- 연관 엔티티는 파라미터로 받기
- 예시:
```java
public Entity toEntity(User user) {
    return Entity.builder()
        .user(user)
        .field1(this.field1)
        .build();
}
```

## API Response 패턴
- 모든 응답은 ApiResponseUtil 사용
- 성공 응답: `ApiResponseUtil.sendApiResponse(HttpStatus, code, message, data, null)`
- 실패 응답: CustomException 발생 시 GlobalExceptionHandler가 자동 처리
- 예시:
```java
return ApiResponseUtil.sendApiResponse(
    HttpStatus.OK,
    "sm.common.success.default",
    "success",
    response,
    null
);
```

## Validation 규칙
- Request DTO에 @Valid 사용
- 검증 실패 시 GlobalExceptionHandler가 MethodArgumentNotValidException 처리
- 자동으로 BAD_REQUEST(400) 반환
- 커스텀 검증: jakarta.validation 어노테이션 사용 (@NotNull, @NotBlank, @Min, @Max 등)

## Service 레이어 구조
- 패키지: `com.codingcat.aipersonalfinance.api.service`
- 도메인별 서브 패키지 가능: `api.service.{module}` (예: api.service.ledger)
- Service 클래스명: `{Domain}Service` (예: LedgerService, UserService)
- 각 Service는 단일 책임 원칙 준수

## Transaction 관리
- 클래스 레벨: `@Transactional(readOnly = true)` (기본값)
- 쓰기 메서드: `@Transactional` 메서드 레벨에 명시
- 예시:
```java
@Service
@Transactional(readOnly = true)
public class SomeService {
    // 읽기 전용 메서드들
    public Data getData() { ... }

    // 쓰기 메서드
    @Transactional
    public void create() { ... }
}
```

## 전체 플로우 예시
```java
// Controller
@PostMapping("/api/v1/client/resources")
public ResponseEntity<?> create(
    @AuthenticationPrincipal UserPrincipal userPrincipal,
    @Valid @RequestBody CreateRequest request
) {
    return service.create(userPrincipal.getAuthDto(), request);
}

// Service
@Service
@Transactional(readOnly = true)
public class SomeService {

    @Transactional
    public ResponseEntity<?> create(AuthDto authDto, CreateRequest request) {
        User user = userRepository.findByUserId(authDto.getUserId())
            .orElseThrow(() -> new CustomException(
                HttpStatus.BAD_REQUEST,
                "sm.common.fail.user_not_found",
                "올바르지 않은 사용자 정보입니다."
            ));
        Entity entity = request.toEntity(user);
        Entity saved = repository.save(entity);
        return ApiResponseUtil.sendApiResponse(
            HttpStatus.OK,
            "sm.common.success.default",
            "success",
            EntityResponse.from(saved),
            null
        );
    }
}
```