package com.codingcat.aipersonalfinance.service;

import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerCreateRequest;
import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerResponse;
import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerSearchCondition;
import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerUpdateRequest;
import com.codingcat.aipersonalfinance.domain.ledger.Ledger;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerRepository;
import com.codingcat.aipersonalfinance.domain.user.User;
import com.codingcat.aipersonalfinance.domain.user.UserRepository;
import com.codingcat.aipersonalfinance.exception.BusinessException;
import com.codingcat.aipersonalfinance.exception.ErrorCode;
import java.util.List;
import java.util.stream.Collectors;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Ledger(거래 내역) 서비스
 */
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class LedgerService {

  private final LedgerRepository ledgerRepository;
  private final UserRepository userRepository;

  /**
   * 거래 내역을 생성합니다.
   *
   * @param userId 사용자 ID
   * @param request 거래 생성 요청 DTO
   * @return 생성된 거래 내역 응답 DTO
   * @throws BusinessException 사용자를 찾을 수 없는 경우
   */
  @Transactional
  public LedgerResponse createLedger(String userId, LedgerCreateRequest request) {
    User user = findUserByUserId(userId);

    Ledger ledger =
        Ledger.builder()
            .user(user)
            .type(request.getType())
            .amount(request.getAmount())
            .desc(request.getDesc())
            .place(request.getPlace())
            .category(request.getCategory())
            .paymentMethod(request.getPaymentMethod())
            .recordedDate(request.getRecordedDate())
            .isAutoGenerated(false)
            .build();

    Ledger savedLedger = ledgerRepository.save(ledger);
    return LedgerResponse.from(savedLedger);
  }

  /**
   * 거래 내역 상세 정보를 조회합니다.
   *
   * @param userId 사용자 ID
   * @param ledgerId 거래 내역 ID
   * @return 거래 내역 응답 DTO
   * @throws BusinessException 거래를 찾을 수 없거나 접근 권한이 없는 경우
   */
  public LedgerResponse getLedger(String userId, Long ledgerId) {
    Ledger ledger = findLedgerById(ledgerId);
    validateLedgerOwnership(userId, ledger);
    return LedgerResponse.from(ledger);
  }

  /**
   * 거래 내역을 수정합니다.
   *
   * @param userId 사용자 ID
   * @param ledgerId 거래 내역 ID
   * @param request 거래 수정 요청 DTO
   * @return 수정된 거래 내역 응답 DTO
   * @throws BusinessException 거래를 찾을 수 없거나 접근 권한이 없는 경우
   */
  @Transactional
  public LedgerResponse updateLedger(String userId, Long ledgerId, LedgerUpdateRequest request) {
    Ledger ledger = findLedgerById(ledgerId);
    validateLedgerOwnership(userId, ledger);

    ledger.update(
        request.getType(),
        request.getAmount(),
        request.getDesc(),
        request.getPlace(),
        request.getCategory(),
        request.getPaymentMethod(),
        request.getRecordedDate());

    return LedgerResponse.from(ledger);
  }

  /**
   * 거래 내역을 삭제합니다 (Soft Delete).
   *
   * @param userId 사용자 ID
   * @param ledgerId 거래 내역 ID
   * @throws BusinessException 거래를 찾을 수 없거나 접근 권한이 없는 경우
   */
  @Transactional
  public void deleteLedger(String userId, Long ledgerId) {
    Ledger ledger = findLedgerById(ledgerId);
    validateLedgerOwnership(userId, ledger);
    ledger.softDelete();
  }

  /**
   * 거래 내역 목록을 조회합니다 (페이징, 필터링, 정렬).
   *
   * @param userId 사용자 ID
   * @param condition 검색 조건
   * @param pageable 페이징 정보
   * @return 거래 내역 페이지
   */
  public Page<LedgerResponse> getLedgerList(
      String userId, LedgerSearchCondition condition, Pageable pageable) {
    User user = findUserByUserId(userId);

    List<Ledger> ledgers = findLedgersByCondition(user, condition);

    List<LedgerResponse> responses =
        ledgers.stream().map(LedgerResponse::from).collect(Collectors.toList());

    int start = (int) pageable.getOffset();
    int end = Math.min((start + pageable.getPageSize()), responses.size());
    List<LedgerResponse> pagedResponses = responses.subList(start, end);

    return new PageImpl<>(pagedResponses, pageable, responses.size());
  }

  /**
   * 검색 조건에 따라 거래 내역을 조회합니다.
   */
  private List<Ledger> findLedgersByCondition(User user, LedgerSearchCondition condition) {
    if (condition == null) {
      return ledgerRepository.findByUserOrderByRecordedDateDesc(user);
    }

    // 조건이 있는 경우 필터링
    if (condition.getType() != null && condition.getCategory() == null) {
      return ledgerRepository.findByUserAndType(user, condition.getType());
    }

    if (condition.getCategory() != null && condition.getType() == null) {
      return ledgerRepository.findByUserAndCategory(user, condition.getCategory());
    }

    if (condition.getStartDate() != null && condition.getEndDate() != null) {
      if (condition.getCategory() != null) {
        return ledgerRepository.findByUserAndCategoryAndRecordedDateBetween(
            user, condition.getCategory(), condition.getStartDate(), condition.getEndDate());
      }
      return ledgerRepository.findByUserAndRecordedDateBetween(
          user, condition.getStartDate(), condition.getEndDate());
    }

    return ledgerRepository.findByUserOrderByRecordedDateDesc(user);
  }

  /**
   * 사용자 ID로 사용자를 찾습니다.
   *
   * @throws BusinessException 사용자를 찾을 수 없는 경우
   */
  private User findUserByUserId(String userId) {
    return userRepository
        .findByUserId(userId)
        .orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));
  }

  /**
   * 거래 내역 ID로 거래를 찾습니다.
   *
   * @throws BusinessException 거래를 찾을 수 없는 경우
   */
  private Ledger findLedgerById(Long ledgerId) {
    return ledgerRepository
        .findById(ledgerId)
        .orElseThrow(() -> new BusinessException(ErrorCode.LEDGER_NOT_FOUND));
  }

  /**
   * 거래 내역의 소유자를 검증합니다.
   *
   * @throws BusinessException 접근 권한이 없는 경우
   */
  private void validateLedgerOwnership(String userId, Ledger ledger) {
    if (!ledger.getUser().getUserId().equals(userId)) {
      throw new BusinessException(ErrorCode.LEDGER_ACCESS_DENIED);
    }
  }
}
