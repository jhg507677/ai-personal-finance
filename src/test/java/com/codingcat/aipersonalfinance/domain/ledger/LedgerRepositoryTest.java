package com.codingcat.aipersonalfinance.domain.ledger;

import static org.assertj.core.api.Assertions.assertThat;

import com.codingcat.aipersonalfinance.domain.user.User;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.data.jpa.test.autoconfigure.DataJpaTest;

/**
 * LedgerRepository 테스트
 */
@DisplayName("LedgerRepository 테스트")
@DataJpaTest
class LedgerRepositoryTest {

  @Autowired private LedgerRepository ledgerRepository;

  private User testUser;
  private User otherUser;

  @BeforeEach
  void setUp() {
    testUser = User.createTestUser();
    otherUser = User.createTestOtherUser();
  }

  @Nested
  @DisplayName("1. 기본 CRUD 테스트")
  class BasicCrudTests {

    @Test
    @DisplayName("1-1. 거래 내역을 저장할 수 있다")
    void saveLedger() {
      // Given: 새 거래 내역
      Ledger ledger =
          Ledger.builder()
              .user(testUser)
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .place("식당")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.now())
              .isAutoGenerated(false)
              .build();

      // When: 저장
      Ledger savedLedger = ledgerRepository.save(ledger);

      // Then: 저장 성공 및 ID 생성 확인
      assertThat(savedLedger.getIdx()).isNotNull();
      assertThat(savedLedger.getUser()).isEqualTo(testUser);
      assertThat(savedLedger.getAmount()).isEqualByComparingTo(new BigDecimal("50000"));
    }

    @Test
    @DisplayName("1-2. ID로 거래 내역을 조회할 수 있다")
    void findLedgerById() {
      // Given: 저장된 거래 내역
      Ledger savedLedger =
          ledgerRepository.save(
              Ledger.builder()
                  .user(testUser)
                  .type(LedgerType.INCOME)
                  .amount(new BigDecimal("100000"))
                  .desc("월급")
                  .category(Category.SUBSCRIPTION)
                  .paymentMethod(PaymentMethod.TRANSFER)
                  .recordedDate(LocalDate.now())
                  .build());

      // When: ID로 조회
      Optional<Ledger> foundLedger = ledgerRepository.findById(savedLedger.getIdx());

      // Then: 조회 성공
      assertThat(foundLedger).isPresent();
      assertThat(foundLedger.get().getDesc()).isEqualTo("월급");
    }

    @Test
    @DisplayName("1-3. Soft delete된 거래는 @SQLRestriction으로 자동 필터링된다")
    void softDeleteFiltering() {
      // Given: 거래 내역 저장 후 soft delete
      Ledger ledger =
          ledgerRepository.save(
              Ledger.builder()
                  .user(testUser)
                  .type(LedgerType.EXPENSE)
                  .amount(new BigDecimal("10000"))
                  .desc("커피")
                  .category(Category.FOOD)
                  .paymentMethod(PaymentMethod.CARD)
                  .recordedDate(LocalDate.now())
                  .build());

      Long ledgerId = ledger.getIdx();
      ledger.softDelete();
      ledgerRepository.save(ledger);

      // When: ID로 조회 시도
      Optional<Ledger> foundLedger = ledgerRepository.findById(ledgerId);

      // Then: @SQLRestriction으로 인해 조회되지 않음
      assertThat(foundLedger).isEmpty();
    }
  }

  @Nested
  @DisplayName("2. 사용자별 조회 테스트")
  class UserBasedQueryTests {

    @Test
    @DisplayName("2-1. 사용자의 활성 거래 내역을 조회할 수 있다")
    void findByUserAndDeletedAtIsNull() {
      // Given: testUser의 거래 2건, otherUser의 거래 1건
      ledgerRepository.save(createLedger(testUser, "거래1", new BigDecimal("10000")));
      ledgerRepository.save(createLedger(testUser, "거래2", new BigDecimal("20000")));
      ledgerRepository.save(createLedger(otherUser, "다른거래", new BigDecimal("30000")));

      // When: testUser의 거래 조회
      List<Ledger> ledgers = ledgerRepository.findByUserAndDeletedAtIsNull(testUser);

      // Then: testUser의 거래 2건만 조회
      assertThat(ledgers).hasSize(2);
      assertThat(ledgers).allMatch(l -> l.getUser().equals(testUser));
    }

    @Test
    @DisplayName("2-2. 삭제된 거래는 조회되지 않는다")
    void findByUserExcludesDeletedLedgers() {
      // Given: 활성 거래 1건, 삭제된 거래 1건
      ledgerRepository.save(createLedger(testUser, "활성거래", new BigDecimal("10000")));
      Ledger deletedLedger =
          ledgerRepository.save(createLedger(testUser, "삭제된거래", new BigDecimal("20000")));
      deletedLedger.softDelete();
      ledgerRepository.save(deletedLedger);

      // When: 조회
      List<Ledger> ledgers = ledgerRepository.findByUserAndDeletedAtIsNull(testUser);

      // Then: 활성 거래 1건만 조회
      assertThat(ledgers).hasSize(1);
      assertThat(ledgers.get(0).getDesc()).isEqualTo("활성거래");
    }
  }

  @Nested
  @DisplayName("3. 날짜 범위 조회 테스트")
  class DateRangeQueryTests {

    @Test
    @DisplayName("3-1. 특정 기간 내의 거래 내역을 조회할 수 있다")
    void findByDateRange() {
      // Given: 다양한 날짜의 거래 내역
      LocalDate today = LocalDate.now();
      ledgerRepository.save(
          createLedgerWithDate(testUser, "오늘", new BigDecimal("10000"), today));
      ledgerRepository.save(
          createLedgerWithDate(testUser, "어제", new BigDecimal("20000"), today.minusDays(1)));
      ledgerRepository.save(
          createLedgerWithDate(testUser, "일주일전", new BigDecimal("30000"), today.minusDays(7)));

      // When: 최근 3일 거래 조회
      LocalDate startDate = today.minusDays(2);
      LocalDate endDate = today;
      List<Ledger> ledgers =
          ledgerRepository.findByUserAndRecordedDateBetweenAndDeletedAtIsNull(
              testUser, startDate, endDate);

      // Then: 2건 조회 (오늘, 어제)
      assertThat(ledgers).hasSize(2);
      assertThat(ledgers)
          .extracting(Ledger::getDesc)
          .containsExactlyInAnyOrder("오늘", "어제");
    }

    @Test
    @DisplayName("3-2. 범위 밖의 거래는 조회되지 않는다")
    void dateRangeExcludesOutOfRange() {
      // Given: 다양한 날짜의 거래
      LocalDate today = LocalDate.now();
      ledgerRepository.save(
          createLedgerWithDate(testUser, "30일전", new BigDecimal("10000"), today.minusDays(30)));

      // When: 최근 7일 조회
      List<Ledger> ledgers =
          ledgerRepository.findByUserAndRecordedDateBetweenAndDeletedAtIsNull(
              testUser, today.minusDays(7), today);

      // Then: 0건
      assertThat(ledgers).isEmpty();
    }
  }

  @Nested
  @DisplayName("4. 카테고리별 조회 테스트")
  class CategoryQueryTests {

    @Test
    @DisplayName("4-1. 특정 카테고리의 거래 내역을 조회할 수 있다")
    void findByCategory() {
      // Given: 다양한 카테고리의 거래
      ledgerRepository.save(
          createLedgerWithCategory(testUser, "식비1", new BigDecimal("10000"), Category.FOOD));
      ledgerRepository.save(
          createLedgerWithCategory(testUser, "식비2", new BigDecimal("20000"), Category.FOOD));
      ledgerRepository.save(
          createLedgerWithCategory(
              testUser, "교통비", new BigDecimal("5000"), Category.TRANSPORT));

      // When: FOOD 카테고리 조회
      List<Ledger> ledgers =
          ledgerRepository.findByUserAndCategoryAndDeletedAtIsNull(testUser, Category.FOOD);

      // Then: FOOD 카테고리 2건만 조회
      assertThat(ledgers).hasSize(2);
      assertThat(ledgers).allMatch(l -> l.getCategory() == Category.FOOD);
    }

    @Test
    @DisplayName("4-2. 다른 카테고리의 거래는 제외된다")
    void categoryFilterExcludesOthers() {
      // Given: FOOD 카테고리만 저장
      ledgerRepository.save(
          createLedgerWithCategory(
              testUser, "교통비", new BigDecimal("5000"), Category.TRANSPORT));

      // When: FOOD 카테고리 조회
      List<Ledger> ledgers =
          ledgerRepository.findByUserAndCategoryAndDeletedAtIsNull(testUser, Category.FOOD);

      // Then: 0건
      assertThat(ledgers).isEmpty();
    }
  }

  @Nested
  @DisplayName("5. 거래 유형별 조회 테스트")
  class LedgerTypeQueryTests {

    @Test
    @DisplayName("5-1. 지출 거래만 조회할 수 있다")
    void findExpensesOnly() {
      // Given: 수입 1건, 지출 2건
      ledgerRepository.save(createLedgerWithType(testUser, "월급", new BigDecimal("1000000"), LedgerType.INCOME));
      ledgerRepository.save(createLedgerWithType(testUser, "식비", new BigDecimal("50000"), LedgerType.EXPENSE));
      ledgerRepository.save(createLedgerWithType(testUser, "교통비", new BigDecimal("10000"), LedgerType.EXPENSE));

      // When: 지출만 조회
      List<Ledger> expenses =
          ledgerRepository.findByUserAndTypeAndDeletedAtIsNull(testUser, LedgerType.EXPENSE);

      // Then: 지출 2건만 조회
      assertThat(expenses).hasSize(2);
      assertThat(expenses).allMatch(l -> l.getType() == LedgerType.EXPENSE);
    }

    @Test
    @DisplayName("5-2. 수입 거래만 조회할 수 있다")
    void findIncomesOnly() {
      // Given: 수입 2건, 지출 1건
      ledgerRepository.save(createLedgerWithType(testUser, "월급", new BigDecimal("2000000"), LedgerType.INCOME));
      ledgerRepository.save(createLedgerWithType(testUser, "부수입", new BigDecimal("500000"), LedgerType.INCOME));
      ledgerRepository.save(createLedgerWithType(testUser, "식비", new BigDecimal("50000"), LedgerType.EXPENSE));

      // When: 수입만 조회
      List<Ledger> incomes =
          ledgerRepository.findByUserAndTypeAndDeletedAtIsNull(testUser, LedgerType.INCOME);

      // Then: 수입 2건만 조회
      assertThat(incomes).hasSize(2);
      assertThat(incomes).allMatch(l -> l.getType() == LedgerType.INCOME);
    }
  }

  @Nested
  @DisplayName("6. 통계 쿼리 테스트")
  class StatisticsQueryTests {

    @Test
    @DisplayName("6-1. 카테고리별 지출 합계를 계산할 수 있다")
    void calculateTotalByCategory() {
      // Given: 카테고리별 지출 데이터
      LocalDate today = LocalDate.now();
      ledgerRepository.save(
          createExpenseWithCategory(testUser, "식비1", new BigDecimal("10000"), Category.FOOD, today));
      ledgerRepository.save(
          createExpenseWithCategory(testUser, "식비2", new BigDecimal("20000"), Category.FOOD, today));
      ledgerRepository.save(
          createExpenseWithCategory(testUser, "교통비", new BigDecimal("5000"), Category.TRANSPORT, today));

      // When: 카테고리별 합계 조회
      List<Object[]> results =
          ledgerRepository.calculateTotalByCategory(
              testUser, LedgerType.EXPENSE, today.minusDays(1), today.plusDays(1));

      // Then: 카테고리별 합계 확인
      assertThat(results).hasSize(2);
      // FOOD: 30000, TRANSPORTATION: 5000
    }

    @Test
    @DisplayName("6-2. 특정 기간의 총 지출을 계산할 수 있다")
    void calculateTotalByTypeAndDateRange() {
      // Given: 기간별 지출 데이터
      LocalDate today = LocalDate.now();
      ledgerRepository.save(
          createExpenseWithDate(testUser, "오늘지출1", new BigDecimal("10000"), today));
      ledgerRepository.save(
          createExpenseWithDate(testUser, "오늘지출2", new BigDecimal("20000"), today));

      // When: 오늘의 총 지출 조회
      BigDecimal totalExpense =
          ledgerRepository.calculateTotalByTypeAndDateRange(
              testUser, LedgerType.EXPENSE, today, today);

      // Then: 30000원
      assertThat(totalExpense).isEqualByComparingTo(new BigDecimal("30000"));
    }

    @Test
    @DisplayName("6-3. 데이터가 없을 때 합계는 0을 반환한다")
    void calculateTotalReturnsZeroWhenNoData() {
      // Given: 데이터 없음
      LocalDate today = LocalDate.now();

      // When: 합계 조회
      BigDecimal totalExpense =
          ledgerRepository.calculateTotalByTypeAndDateRange(
              testUser, LedgerType.EXPENSE, today, today);

      // Then: 0원
      assertThat(totalExpense).isEqualByComparingTo(BigDecimal.ZERO);
    }
  }

  @Nested
  @DisplayName("7. 복합 조건 조회 테스트")
  class ComplexQueryTests {

    @Test
    @DisplayName("7-1. 카테고리와 날짜 범위를 동시에 필터링할 수 있다")
    void findByCategoryAndDateRange() {
      // Given: 다양한 조건의 거래
      LocalDate today = LocalDate.now();
      ledgerRepository.save(
          createComplexLedger(testUser, "식비오늘", new BigDecimal("10000"), Category.FOOD, today));
      ledgerRepository.save(
          createComplexLedger(testUser, "식비어제", new BigDecimal("20000"), Category.FOOD, today.minusDays(1)));
      ledgerRepository.save(
          createComplexLedger(testUser, "교통비오늘", new BigDecimal("5000"), Category.TRANSPORT, today));

      // When: FOOD 카테고리 + 오늘 날짜로 조회
      List<Ledger> ledgers =
          ledgerRepository.findByUserAndCategoryAndRecordedDateBetweenAndDeletedAtIsNull(
              testUser, Category.FOOD, today, today);

      // Then: 1건만 조회 (식비오늘)
      assertThat(ledgers).hasSize(1);
      assertThat(ledgers.get(0).getDesc()).isEqualTo("식비오늘");
    }

    @Test
    @DisplayName("7-2. 날짜 역순으로 정렬된 목록을 조회할 수 있다")
    void findAllOrderByRecordedDateDesc() {
      // Given: 다양한 날짜의 거래
      LocalDate today = LocalDate.now();
      ledgerRepository.save(createLedgerWithDate(testUser, "오늘", new BigDecimal("10000"), today));
      ledgerRepository.save(createLedgerWithDate(testUser, "어제", new BigDecimal("20000"), today.minusDays(1)));
      ledgerRepository.save(createLedgerWithDate(testUser, "그저께", new BigDecimal("30000"), today.minusDays(2)));

      // When: 날짜 역순 조회
      List<Ledger> ledgers =
          ledgerRepository.findByUserAndDeletedAtIsNullOrderByRecordedDateDesc(testUser);

      // Then: 최신순 정렬 확인
      assertThat(ledgers).hasSize(3);
      assertThat(ledgers.get(0).getDesc()).isEqualTo("오늘");
      assertThat(ledgers.get(1).getDesc()).isEqualTo("어제");
      assertThat(ledgers.get(2).getDesc()).isEqualTo("그저께");
    }
  }

  @Nested
  @DisplayName("8. 경계값 테스트")
  class EdgeCaseTests {

    @Test
    @DisplayName("8-1. 빈 리스트를 정상적으로 처리한다")
    void handleEmptyList() {
      // Given: 데이터 없음

      // When: 조회
      List<Ledger> ledgers = ledgerRepository.findByUserAndDeletedAtIsNull(testUser);

      // Then: 빈 리스트 반환
      assertThat(ledgers).isEmpty();
    }

    @Test
    @DisplayName("8-2. 0원 거래도 정상 저장된다")
    void handleZeroAmount() {
      // Given: 0원 거래
      Ledger ledger =
          ledgerRepository.save(
              Ledger.builder()
                  .user(testUser)
                  .type(LedgerType.EXPENSE)
                  .amount(BigDecimal.ZERO)
                  .desc("0원 테스트")
                  .category(Category.ETC)
                  .paymentMethod(PaymentMethod.CARD)
                  .recordedDate(LocalDate.now())
                  .build());

      // When: 조회
      Optional<Ledger> foundLedger = ledgerRepository.findById(ledger.getIdx());

      // Then: 정상 조회
      assertThat(foundLedger).isPresent();
      assertThat(foundLedger.get().getAmount()).isEqualByComparingTo(BigDecimal.ZERO);
    }

    @Test
    @DisplayName("8-3. place가 null인 거래도 정상 저장된다")
    void handleNullPlace() {
      // Given: place가 null인 거래
      Ledger ledger =
          ledgerRepository.save(
              Ledger.builder()
                  .user(testUser)
                  .type(LedgerType.EXPENSE)
                  .amount(new BigDecimal("10000"))
                  .desc("장소 없음")
                  .place(null)
                  .category(Category.ETC)
                  .paymentMethod(PaymentMethod.CARD)
                  .recordedDate(LocalDate.now())
                  .build());

      // When: 조회
      Optional<Ledger> foundLedger = ledgerRepository.findById(ledger.getIdx());

      // Then: 정상 조회, place는 null
      assertThat(foundLedger).isPresent();
      assertThat(foundLedger.get().getPlace()).isNull();
    }

    @Test
    @DisplayName("8-4. 미래 날짜의 거래도 저장할 수 있다 (예약 거래)")
    void handleFutureDate() {
      // Given: 미래 날짜 거래
      LocalDate futureDate = LocalDate.now().plusDays(7);
      Ledger ledger =
          ledgerRepository.save(
              Ledger.builder()
                  .user(testUser)
                  .type(LedgerType.EXPENSE)
                  .amount(new BigDecimal("100000"))
                  .desc("예약된 지출")
                  .category(Category.ETC)
                  .paymentMethod(PaymentMethod.CARD)
                  .recordedDate(futureDate)
                  .build());

      // When: 조회
      Optional<Ledger> foundLedger = ledgerRepository.findById(ledger.getIdx());

      // Then: 정상 조회
      assertThat(foundLedger).isPresent();
      assertThat(foundLedger.get().getRecordedDate()).isEqualTo(futureDate);
    }
  }

  // ===== Helper Methods =====

  private Ledger createLedger(User user, String desc, BigDecimal amount) {
    return Ledger.builder()
        .user(user)
        .type(LedgerType.EXPENSE)
        .amount(amount)
        .desc(desc)
        .category(Category.ETC)
        .paymentMethod(PaymentMethod.CARD)
        .recordedDate(LocalDate.now())
        .build();
  }

  private Ledger createLedgerWithDate(User user, String desc, BigDecimal amount, LocalDate date) {
    return Ledger.builder()
        .user(user)
        .type(LedgerType.EXPENSE)
        .amount(amount)
        .desc(desc)
        .category(Category.ETC)
        .paymentMethod(PaymentMethod.CARD)
        .recordedDate(date)
        .build();
  }

  private Ledger createLedgerWithCategory(
      User user, String desc, BigDecimal amount, Category category) {
    return Ledger.builder()
        .user(user)
        .type(LedgerType.EXPENSE)
        .amount(amount)
        .desc(desc)
        .category(category)
        .paymentMethod(PaymentMethod.CARD)
        .recordedDate(LocalDate.now())
        .build();
  }

  private Ledger createLedgerWithType(
      User user, String desc, BigDecimal amount, LedgerType type) {
    return Ledger.builder()
        .user(user)
        .type(type)
        .amount(amount)
        .desc(desc)
        .category(type == LedgerType.INCOME ? Category.SUBSCRIPTION : Category.FOOD)
        .paymentMethod(PaymentMethod.CARD)
        .recordedDate(LocalDate.now())
        .build();
  }

  private Ledger createExpenseWithCategory(
      User user, String desc, BigDecimal amount, Category category, LocalDate date) {
    return Ledger.builder()
        .user(user)
        .type(LedgerType.EXPENSE)
        .amount(amount)
        .desc(desc)
        .category(category)
        .paymentMethod(PaymentMethod.CARD)
        .recordedDate(date)
        .build();
  }

  private Ledger createExpenseWithDate(User user, String desc, BigDecimal amount, LocalDate date) {
    return Ledger.builder()
        .user(user)
        .type(LedgerType.EXPENSE)
        .amount(amount)
        .desc(desc)
        .category(Category.ETC)
        .paymentMethod(PaymentMethod.CARD)
        .recordedDate(date)
        .build();
  }

  private Ledger createComplexLedger(
      User user, String desc, BigDecimal amount, Category category, LocalDate date) {
    return Ledger.builder()
        .user(user)
        .type(LedgerType.EXPENSE)
        .amount(amount)
        .desc(desc)
        .category(category)
        .paymentMethod(PaymentMethod.CARD)
        .recordedDate(date)
        .build();
  }
}
