package com.codingcat.aipersonalfinance.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerCreateRequest;
import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerResponse;
import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerSearchCondition;
import com.codingcat.aipersonalfinance.api.dto.ledger.LedgerUpdateRequest;
import com.codingcat.aipersonalfinance.domain.ledger.Category;
import com.codingcat.aipersonalfinance.domain.ledger.Ledger;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerRepository;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerType;
import com.codingcat.aipersonalfinance.domain.ledger.PaymentMethod;
import com.codingcat.aipersonalfinance.domain.user.User;
import com.codingcat.aipersonalfinance.domain.user.UserRepository;
import com.codingcat.aipersonalfinance.exception.BusinessException;
import com.codingcat.aipersonalfinance.exception.ErrorCode;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;

/**
 * LedgerService 테스트
 */
@DisplayName("LedgerService 테스트")
@ExtendWith(MockitoExtension.class)
class LedgerServiceTest {

  @Mock private LedgerRepository ledgerRepository;
  @Mock private UserRepository userRepository;

  @InjectMocks private LedgerService ledgerService;

  private User testUser;
  private User otherUser;
  private Ledger testLedger;

  @BeforeEach
  void setUp() {
    testUser = User.createTestUser();
    otherUser = User.createTestOtherUser();

    testLedger =
        Ledger.builder()
            .user(testUser)
            .type(LedgerType.EXPENSE)
            .amount(new BigDecimal("50000"))
            .desc("점심 식사")
            .place("식당")
            .category(Category.FOOD)
            .paymentMethod(PaymentMethod.CARD)
            .recordedDate(LocalDate.now())
            .isAutoGenerated(false)
            .build();
  }

  @Nested
  @DisplayName("1. 거래 생성 테스트")
  class CreateLedgerTests {

    @Test
    @DisplayName("1-1. 유효한 요청으로 거래를 생성할 수 있다")
    void createLedger_Success() {
      // Given
      String userId = "testId";
      LedgerCreateRequest request =
          LedgerCreateRequest.builder()
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .place("식당")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.now())
              .build();

      given(userRepository.findByUserId(userId)).willReturn(Optional.of(testUser));
      given(ledgerRepository.save(any(Ledger.class))).willReturn(testLedger);

      // When
      LedgerResponse response = ledgerService.createLedger(userId, request);

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getType()).isEqualTo(LedgerType.EXPENSE);
      assertThat(response.getAmount()).isEqualByComparingTo(new BigDecimal("50000"));
      assertThat(response.getDesc()).isEqualTo("점심 식사");
      verify(userRepository).findByUserId(userId);
      verify(ledgerRepository).save(any(Ledger.class));
    }

    @Test
    @DisplayName("1-2. 존재하지 않는 사용자로 거래 생성 시 예외가 발생한다")
    void createLedger_UserNotFound() {
      // Given
      String userId = "invalidId";
      LedgerCreateRequest request =
          LedgerCreateRequest.builder()
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.now())
              .build();

      given(userRepository.findByUserId(userId)).willReturn(Optional.empty());

      // When & Then
      assertThatThrownBy(() -> ledgerService.createLedger(userId, request))
          .isInstanceOf(BusinessException.class)
          .hasFieldOrPropertyWithValue("errorCode", ErrorCode.USER_NOT_FOUND);

      verify(userRepository).findByUserId(userId);
      verify(ledgerRepository, never()).save(any(Ledger.class));
    }
  }

  @Nested
  @DisplayName("2. 거래 조회 테스트")
  class GetLedgerTests {

    @Test
    @DisplayName("2-1. ID로 거래 상세 정보를 조회할 수 있다")
    void getLedger_Success() {
      // Given
      Long ledgerId = 1L;
      String userId = "testId";

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When
      LedgerResponse response = ledgerService.getLedger(userId, ledgerId);

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getDesc()).isEqualTo("점심 식사");
      verify(ledgerRepository).findById(ledgerId);
    }

    @Test
    @DisplayName("2-2. 존재하지 않는 거래 조회 시 예외가 발생한다")
    void getLedger_NotFound() {
      // Given
      Long ledgerId = 999L;
      String userId = "testId";

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.empty());

      // When & Then
      assertThatThrownBy(() -> ledgerService.getLedger(userId, ledgerId))
          .isInstanceOf(BusinessException.class)
          .hasFieldOrPropertyWithValue("errorCode", ErrorCode.LEDGER_NOT_FOUND);
    }

    @Test
    @DisplayName("2-3. 다른 사용자의 거래 조회 시 예외가 발생한다")
    void getLedger_AccessDenied() {
      // Given
      Long ledgerId = 1L;
      String otherUserId = "otherTestId";

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When & Then
      assertThatThrownBy(() -> ledgerService.getLedger(otherUserId, ledgerId))
          .isInstanceOf(BusinessException.class)
          .hasFieldOrPropertyWithValue("errorCode", ErrorCode.LEDGER_ACCESS_DENIED);
    }
  }

  @Nested
  @DisplayName("3. 거래 수정 테스트")
  class UpdateLedgerTests {

    @Test
    @DisplayName("3-1. 본인의 거래를 수정할 수 있다")
    void updateLedger_Success() {
      // Given
      Long ledgerId = 1L;
      String userId = "testId";
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder()
              .amount(new BigDecimal("60000"))
              .desc("저녁 식사")
              .place("레스토랑")
              .build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When
      LedgerResponse response = ledgerService.updateLedger(userId, ledgerId, request);

      // Then
      assertThat(response).isNotNull();
      verify(ledgerRepository).findById(ledgerId);
    }

    @Test
    @DisplayName("3-2. 다른 사용자의 거래 수정 시 예외가 발생한다")
    void updateLedger_AccessDenied() {
      // Given
      Long ledgerId = 1L;
      String otherUserId = "otherTestId";
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder().amount(new BigDecimal("60000")).build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When & Then
      assertThatThrownBy(() -> ledgerService.updateLedger(otherUserId, ledgerId, request))
          .isInstanceOf(BusinessException.class)
          .hasFieldOrPropertyWithValue("errorCode", ErrorCode.LEDGER_ACCESS_DENIED);
    }

    @Test
    @DisplayName("3-3. 존재하지 않는 거래 수정 시 예외가 발생한다")
    void updateLedger_NotFound() {
      // Given
      Long ledgerId = 999L;
      String userId = "testId";
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder().amount(new BigDecimal("60000")).build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.empty());

      // When & Then
      assertThatThrownBy(() -> ledgerService.updateLedger(userId, ledgerId, request))
          .isInstanceOf(BusinessException.class)
          .hasFieldOrPropertyWithValue("errorCode", ErrorCode.LEDGER_NOT_FOUND);
    }
  }

  @Nested
  @DisplayName("4. 거래 삭제 테스트")
  class DeleteLedgerTests {

    @Test
    @DisplayName("4-1. 본인의 거래를 삭제할 수 있다 (Soft Delete)")
    void deleteLedger_Success() {
      // Given
      Long ledgerId = 1L;
      String userId = "testId";

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When
      ledgerService.deleteLedger(userId, ledgerId);

      // Then
      verify(ledgerRepository).findById(ledgerId);
      assertThat(testLedger.getDeletedDateTime()).isNotNull();
    }

    @Test
    @DisplayName("4-2. 다른 사용자의 거래 삭제 시 예외가 발생한다")
    void deleteLedger_AccessDenied() {
      // Given
      Long ledgerId = 1L;
      String otherUserId = "otherTestId";

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When & Then
      assertThatThrownBy(() -> ledgerService.deleteLedger(otherUserId, ledgerId))
          .isInstanceOf(BusinessException.class)
          .hasFieldOrPropertyWithValue("errorCode", ErrorCode.LEDGER_ACCESS_DENIED);
    }
  }

  @Nested
  @DisplayName("5. 거래 목록 조회 테스트")
  class GetLedgerListTests {

    @Test
    @DisplayName("5-1. 사용자의 거래 목록을 페이징하여 조회할 수 있다")
    void getLedgerList_Success() {
      // Given
      String userId = "testId";
      Pageable pageable = PageRequest.of(0, 10);
      List<Ledger> ledgers = List.of(testLedger);
      Page<Ledger> ledgerPage = new PageImpl<>(ledgers, pageable, 1);

      given(userRepository.findByUserId(userId)).willReturn(Optional.of(testUser));
      given(ledgerRepository.findByUserOrderByRecordedDateDesc(testUser))
          .willReturn(ledgers);

      // When
      Page<LedgerResponse> response = ledgerService.getLedgerList(userId, null, pageable);

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getContent()).hasSize(1);
      assertThat(response.getContent().get(0).getDesc()).isEqualTo("점심 식사");
    }

    @Test
    @DisplayName("5-2. 검색 조건으로 거래 목록을 필터링할 수 있다")
    void getLedgerList_WithCondition() {
      // Given
      String userId = "testId";
      LedgerSearchCondition condition =
          LedgerSearchCondition.builder()
              .type(LedgerType.EXPENSE)
              .build();
      Pageable pageable = PageRequest.of(0, 10);

      given(userRepository.findByUserId(userId)).willReturn(Optional.of(testUser));
      given(ledgerRepository.findByUserAndType(testUser, LedgerType.EXPENSE))
          .willReturn(List.of(testLedger));

      // When
      Page<LedgerResponse> response = ledgerService.getLedgerList(userId, condition, pageable);

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getContent()).isNotEmpty();
    }
  }
}
