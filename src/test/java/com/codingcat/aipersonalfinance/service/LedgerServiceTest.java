package com.codingcat.aipersonalfinance.service;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;

import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerCreateRequest;
import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerResponse;
import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerSearchRequest;
import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerUpdateRequest;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerService;
import com.codingcat.aipersonalfinance.domain.ledger.Category;
import com.codingcat.aipersonalfinance.domain.ledger.Ledger;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerRepository;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerType;
import com.codingcat.aipersonalfinance.domain.ledger.PaymentMethod;
import com.codingcat.aipersonalfinance.domain.user.User;
import com.codingcat.aipersonalfinance.domain.user.UserRepository;
import com.codingcat.aipersonalfinance.module.exception.CustomException;
import com.codingcat.aipersonalfinance.module.model.ServiceType;
import com.codingcat.aipersonalfinance.module.response.ApiResponseVo;
import com.codingcat.aipersonalfinance.module.response.PageResponse;
import com.codingcat.aipersonalfinance.module.security.AuthDto;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;

/**
 * LedgerService 테스트
 */
@DisplayName("LedgerService 테스트")
@ExtendWith(MockitoExtension.class)
class LedgerServiceTest {

  @Mock private LedgerRepository ledgerRepository;
  @Mock private UserRepository userRepository;

  @InjectMocks private LedgerService ledgerService;

  private User testUser;
  private User otherUser;
  private Ledger testLedger;

  @BeforeEach
  void setUp() {
    testUser = User.createTestUser();
    otherUser = User.createTestOtherUser();

    testLedger =
        Ledger.builder()
            .user(testUser)
            .type(LedgerType.EXPENSE)
            .amount(new BigDecimal("50000"))
            .desc("점심 식사")
            .place("식당")
            .category(Category.FOOD)
            .paymentMethod(PaymentMethod.CARD)
            .recordedDate(LocalDate.now())
            .isAutoGenerated(false)
            .build();
  }

  @Nested
  @DisplayName("1. 거래 생성 테스트")
  class CreateLedgerTests {

    @Test
    @DisplayName("1-1. 유효한 요청으로 거래를 생성할 수 있다")
    void createLedger_Success() {
      // Given
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();
      LedgerCreateRequest request =
          LedgerCreateRequest.builder()
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .place("식당")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.now())
              .build();

      given(userRepository.findByEmail("test@test.com")).willReturn(Optional.of(testUser));
      given(ledgerRepository.save(any(Ledger.class))).willReturn(testLedger);

      // When
      ResponseEntity<?> result = ledgerService.createLedger(authDto, request);
      ApiResponseVo<?> apiResponse = (ApiResponseVo<?>) result.getBody();
      LedgerResponse response = (LedgerResponse) apiResponse.getContent();

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getType()).isEqualTo(LedgerType.EXPENSE);
      assertThat(response.getAmount()).isEqualByComparingTo(new BigDecimal("50000"));
      assertThat(response.getDesc()).isEqualTo("점심 식사");
      verify(userRepository).findByEmail("test@test.com");
      verify(ledgerRepository).save(any(Ledger.class));
    }

    @Test
    @DisplayName("1-2. 존재하지 않는 사용자로 거래 생성 시 예외가 발생한다")
    void createLedger_UserNotFound() {
      // Given
      AuthDto authDto = AuthDto.builder()
          .email("invalid@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(999L)
          .build();
      LedgerCreateRequest request =
          LedgerCreateRequest.builder()
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.now())
              .build();

      given(userRepository.findByEmail("invalid@test.com")).willReturn(Optional.empty());

      // When & Then
      assertThatThrownBy(() -> ledgerService.createLedger(authDto, request))
          .isInstanceOf(CustomException.class);

      verify(userRepository).findByEmail("invalid@test.com");
      verify(ledgerRepository, never()).save(any(Ledger.class));
    }
  }

  @Nested
  @DisplayName("2. 거래 조회 테스트")
  class GetLedgerTests {

    @Test
    @DisplayName("2-1. ID로 거래 상세 정보를 조회할 수 있다")
    void getLedger_Success() {
      // Given
      Long ledgerId = 1L;
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When
      ResponseEntity<?> result = ledgerService.getLedger(authDto, ledgerId);
      ApiResponseVo<?> apiResponse = (ApiResponseVo<?>) result.getBody();
      LedgerResponse response = (LedgerResponse) apiResponse.getContent();

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getDesc()).isEqualTo("점심 식사");
      verify(ledgerRepository).findById(ledgerId);
    }

    @Test
    @DisplayName("2-2. 존재하지 않는 거래 조회 시 예외가 발생한다")
    void getLedger_NotFound() {
      // Given
      Long ledgerId = 999L;
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.empty());

      // When & Then
      assertThatThrownBy(() -> ledgerService.getLedger(authDto, ledgerId))
          .isInstanceOf(CustomException.class);
    }

    @Test
    @DisplayName("2-3. 다른 사용자의 거래 조회 시 예외가 발생한다")
    void getLedger_AccessDenied() {
      // Given
      Long ledgerId = 1L;
      AuthDto authDto = AuthDto.builder()
          .email("other@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(999L)
          .build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When & Then
      assertThatThrownBy(() -> ledgerService.getLedger(authDto, ledgerId))
          .isInstanceOf(CustomException.class);
    }
  }

  @Nested
  @DisplayName("3. 거래 수정 테스트")
  class UpdateLedgerTests {

    @Test
    @DisplayName("3-1. 본인의 거래를 수정할 수 있다")
    void updateLedger_Success() {
      // Given
      Long ledgerId = 1L;
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder()
              .amount(new BigDecimal("60000"))
              .desc("저녁 식사")
              .place("레스토랑")
              .build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When
      ResponseEntity<?> result = ledgerService.updateLedger(authDto, ledgerId, request);
      ApiResponseVo<?> apiResponse = (ApiResponseVo<?>) result.getBody();
      LedgerResponse response = (LedgerResponse) apiResponse.getContent();

      // Then
      assertThat(response).isNotNull();
      verify(ledgerRepository).findById(ledgerId);
    }

    @Test
    @DisplayName("3-2. 다른 사용자의 거래 수정 시 예외가 발생한다")
    void updateLedger_AccessDenied() {
      // Given
      Long ledgerId = 1L;
      AuthDto authDto = AuthDto.builder()
          .email("other@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(999L)
          .build();
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder().amount(new BigDecimal("60000")).build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When & Then
      assertThatThrownBy(() -> ledgerService.updateLedger(authDto, ledgerId, request))
          .isInstanceOf(CustomException.class);
    }

    @Test
    @DisplayName("3-3. 존재하지 않는 거래 수정 시 예외가 발생한다")
    void updateLedger_NotFound() {
      // Given
      Long ledgerId = 999L;
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder().amount(new BigDecimal("60000")).build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.empty());

      // When & Then
      assertThatThrownBy(() -> ledgerService.updateLedger(authDto, ledgerId, request))
          .isInstanceOf(CustomException.class);
    }
  }

  @Nested
  @DisplayName("4. 거래 삭제 테스트")
  class DeleteLedgerTests {

    @Test
    @DisplayName("4-1. 본인의 거래를 삭제할 수 있다 (Soft Delete)")
    void deleteLedger_Success() {
      // Given
      Long ledgerId = 1L;
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When
      ResponseEntity<?> result = ledgerService.deleteLedger(authDto, ledgerId);

      // Then
      assertThat(result).isNotNull();
      assertThat(result.getStatusCode().value()).isEqualTo(200);
      verify(ledgerRepository).findById(ledgerId);
      // Note: In unit tests with mocked repositories, we verify behavior not state
      // The actual soft delete timestamp would be verified in integration tests
    }

    @Test
    @DisplayName("4-2. 다른 사용자의 거래 삭제 시 예외가 발생한다")
    void deleteLedger_AccessDenied() {
      // Given
      Long ledgerId = 1L;
      AuthDto authDto = AuthDto.builder()
          .email("other@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(999L)
          .build();

      given(ledgerRepository.findById(ledgerId)).willReturn(Optional.of(testLedger));

      // When & Then
      assertThatThrownBy(() -> ledgerService.deleteLedger(authDto, ledgerId))
          .isInstanceOf(CustomException.class);
    }
  }

  @Nested
  @DisplayName("5. 거래 목록 조회 테스트")
  class GetLedgerListTests {

    @Test
    @DisplayName("5-1. 사용자의 거래 목록을 페이징하여 조회할 수 있다")
    void getLedgerList_Success() {
      // Given
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();
      Pageable pageable = PageRequest.of(0, 10);
      List<Ledger> ledgers = List.of(testLedger);
      Page<Ledger> ledgerPage = new PageImpl<>(ledgers, pageable, 1);

      given(userRepository.findByEmail("test@test.com")).willReturn(Optional.of(testUser));
      given(ledgerRepository.findByPageInLedger(testUser, null, pageable))
          .willReturn(ledgerPage);

      // When
      ResponseEntity<?> result = ledgerService.getLedgerList(authDto, null, pageable);
      ApiResponseVo<?> apiResponse = (ApiResponseVo<?>) result.getBody();
      @SuppressWarnings("unchecked")
      PageResponse<LedgerResponse> response = (PageResponse<LedgerResponse>) apiResponse.getContent();

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getData()).hasSize(1);
      assertThat(response.getData().get(0).getDesc()).isEqualTo("점심 식사");
    }

    @Test
    @DisplayName("5-2. 검색 조건으로 거래 목록을 필터링할 수 있다")
    void getLedgerList_WithCondition() {
      // Given
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(testUser.getIdx())
          .build();
      LedgerSearchRequest condition =
          LedgerSearchRequest.builder()
              .type(LedgerType.EXPENSE)
              .build();
      Pageable pageable = PageRequest.of(0, 10);

      List<Ledger> ledgers = List.of(testLedger);
      Page<Ledger> ledgerPage = new PageImpl<>(ledgers, pageable, 1);

      given(userRepository.findByEmail("test@test.com")).willReturn(Optional.of(testUser));
      given(ledgerRepository.findByPageInLedger(testUser, condition, pageable))
          .willReturn(ledgerPage);

      // When
      ResponseEntity<?> result = ledgerService.getLedgerList(authDto, condition, pageable);
      ApiResponseVo<?> apiResponse = (ApiResponseVo<?>) result.getBody();
      @SuppressWarnings("unchecked")
      PageResponse<LedgerResponse> response = (PageResponse<LedgerResponse>) apiResponse.getContent();

      // Then
      assertThat(response).isNotNull();
      assertThat(response.getData()).isNotEmpty();
    }
  }
}
