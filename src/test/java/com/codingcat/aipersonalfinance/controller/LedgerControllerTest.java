package com.codingcat.aipersonalfinance.controller;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.BDDMockito.given;
import static org.mockito.Mockito.doNothing;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.doReturn;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerCreateRequest;
import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerResponse;
import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerSearchRequest;
import com.codingcat.aipersonalfinance.domain.ledger.dto.LedgerUpdateRequest;
import com.codingcat.aipersonalfinance.domain.ledger.Category;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerType;
import com.codingcat.aipersonalfinance.domain.ledger.PaymentMethod;
import com.codingcat.aipersonalfinance.domain.ledger.LedgerService;
import com.codingcat.aipersonalfinance.module.exception.CustomException;
import com.codingcat.aipersonalfinance.module.model.ServiceType;
import com.codingcat.aipersonalfinance.module.security.AuthDto;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.test.context.support.WithMockUser;
import org.springframework.test.web.servlet.MockMvc;

/**
 * LedgerController 테스트
 */
@DisplayName("LedgerController 테스트")
@SpringBootTest
@AutoConfigureMockMvc
class LedgerControllerTest {

  @Autowired private MockMvc mockMvc;
  @Autowired private ObjectMapper objectMapper;

  @MockBean private LedgerService ledgerService;

  @Nested
  @DisplayName("1. 거래 생성 API 테스트")
  class CreateLedgerApiTests {

    @Test
    @DisplayName("1-1. 유효한 요청으로 거래를 생성할 수 있다")
    @WithMockUser(username = "test@test.com")
    void createLedger_Success() throws Exception {
      // Given
      AuthDto authDto = AuthDto.builder()
          .email("test@test.com")
          .serviceType(ServiceType.USER)
          .userIdx(1L)
          .build();

      LedgerCreateRequest request =
          LedgerCreateRequest.builder()
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .place("식당")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.of(2024, 1, 15))
              .build();

      LedgerResponse response =
          LedgerResponse.builder()
              .ledgerIdx(1L)
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .place("식당")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.of(2024, 1, 15))
              .isAutoGenerated(false)
              .createdAt(LocalDateTime.now())
              .build();

      doReturn(ResponseEntity.ok(response))
          .when(ledgerService)
          .createLedger(any(AuthDto.class), any(LedgerCreateRequest.class));

      // When & Then
      mockMvc
          .perform(
              post("/api/v1/client/ledgers")
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(request)))
          .andDo(print())
          .andExpect(status().isOk())
          .andExpect(jsonPath("$.status").value("OK"))
          .andExpect(jsonPath("$.content.ledgerIdx").value(1))
          .andExpect(jsonPath("$.content.amount").value(50000))
          .andExpect(jsonPath("$.content.desc").value("점심 식사"));
    }

    @Test
    @DisplayName("1-2. 필수 필드 누락 시 400 에러가 발생한다")
    @WithMockUser(username = "test@test.com")
    void createLedger_ValidationFail() throws Exception {
      // Given: amount가 null인 잘못된 요청
      LedgerCreateRequest request =
          LedgerCreateRequest.builder()
              .type(LedgerType.EXPENSE)
              .desc("점심 식사")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.now())
              .build();

      // When & Then
      mockMvc
          .perform(
              post("/api/v1/client/ledgers")
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(request)))
          .andDo(print())
          .andExpect(status().isBadRequest());
    }
  }

  @Nested
  @DisplayName("2. 거래 조회 API 테스트")
  class GetLedgerApiTests {

    @Test
    @DisplayName("2-1. ID로 거래 상세 정보를 조회할 수 있다")
    @WithMockUser(username = "test@test.com")
    void getLedger_Success() throws Exception {
      // Given
      Long ledgerId = 1L;
      LedgerResponse response =
          LedgerResponse.builder()
              .ledgerIdx(ledgerId)
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.of(2024, 1, 15))
              .build();

      doReturn(ResponseEntity.ok(response))
          .when(ledgerService)
          .getLedger(any(AuthDto.class), eq(ledgerId));

      // When & Then
      mockMvc
          .perform(get("/api/v1/client/ledgers/{ledgerId}", ledgerId))
          .andDo(print())
          .andExpect(status().isOk())
          .andExpect(jsonPath("$.status").value("OK"))
          .andExpect(jsonPath("$.content.ledgerIdx").value(1))
          .andExpect(jsonPath("$.content.desc").value("점심 식사"));
    }

    @Test
    @DisplayName("2-2. 존재하지 않는 거래 조회 시 404 에러가 발생한다")
    @WithMockUser(username = "test@test.com")
    void getLedger_NotFound() throws Exception {
      // Given
      Long ledgerId = 999L;
      given(ledgerService.getLedger(any(AuthDto.class), eq(ledgerId)))
          .willThrow(new CustomException(
              org.springframework.http.HttpStatus.NOT_FOUND,
              "ai.ledger.fail.not_found",
              "거래를 찾을 수 없습니다."));

      // When & Then
      mockMvc
          .perform(get("/api/v1/client/ledgers/{ledgerId}", ledgerId))
          .andDo(print())
          .andExpect(status().isNotFound());
    }

    @Test
    @DisplayName("2-3. 다른 사용자의 거래 조회 시 403 에러가 발생한다")
    @WithMockUser(username = "test@test.com")
    void getLedger_AccessDenied() throws Exception {
      // Given
      Long ledgerId = 1L;
      given(ledgerService.getLedger(any(AuthDto.class), eq(ledgerId)))
          .willThrow(new CustomException(
              org.springframework.http.HttpStatus.FORBIDDEN,
              "ai.ledger.fail.access_denied",
              "거래에 접근할 수 없습니다."));

      // When & Then
      mockMvc
          .perform(get("/api/v1/client/ledgers/{ledgerId}", ledgerId))
          .andDo(print())
          .andExpect(status().isForbidden());
    }
  }

  @Nested
  @DisplayName("3. 거래 수정 API 테스트")
  class UpdateLedgerApiTests {

    @Test
    @DisplayName("3-1. 거래를 수정할 수 있다")
    @WithMockUser(username = "test@test.com")
    void updateLedger_Success() throws Exception {
      // Given
      Long ledgerId = 1L;
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder()
              .amount(new BigDecimal("60000"))
              .desc("저녁 식사")
              .build();

      LedgerResponse response =
          LedgerResponse.builder()
              .ledgerIdx(ledgerId)
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("60000"))
              .desc("저녁 식사")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.of(2024, 1, 15))
              .build();

      doReturn(ResponseEntity.ok(response))
          .when(ledgerService)
          .updateLedger(any(AuthDto.class), eq(ledgerId), any(LedgerUpdateRequest.class));

      // When & Then
      mockMvc
          .perform(
              put("/api/v1/client/ledgers/{ledgerId}", ledgerId)
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(request)))
          .andDo(print())
          .andExpect(status().isOk())
          .andExpect(jsonPath("$.status").value("OK"))
          .andExpect(jsonPath("$.content.amount").value(60000))
          .andExpect(jsonPath("$.content.desc").value("저녁 식사"));
    }

    @Test
    @DisplayName("3-2. 다른 사용자의 거래 수정 시 403 에러가 발생한다")
    @WithMockUser(username = "test@test.com")
    void updateLedger_AccessDenied() throws Exception {
      // Given
      Long ledgerId = 1L;
      LedgerUpdateRequest request =
          LedgerUpdateRequest.builder().amount(new BigDecimal("60000")).build();

      given(ledgerService.updateLedger(any(AuthDto.class), eq(ledgerId), any(LedgerUpdateRequest.class)))
          .willThrow(new CustomException(
              org.springframework.http.HttpStatus.FORBIDDEN,
              "ai.ledger.fail.access_denied",
              "거래에 접근할 수 없습니다."));

      // When & Then
      mockMvc
          .perform(
              put("/api/v1/client/ledgers/{ledgerId}", ledgerId)
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(objectMapper.writeValueAsString(request)))
          .andDo(print())
          .andExpect(status().isForbidden());
    }
  }

  @Nested
  @DisplayName("4. 거래 삭제 API 테스트")
  class DeleteLedgerApiTests {

    @Test
    @DisplayName("4-1. 거래를 삭제할 수 있다")
    @WithMockUser(username = "test@test.com")
    void deleteLedger_Success() throws Exception {
      // Given
      Long ledgerId = 1L;
      doReturn(ResponseEntity.ok(null))
          .when(ledgerService)
          .deleteLedger(any(AuthDto.class), eq(ledgerId));

      // When & Then
      mockMvc
          .perform(delete("/api/v1/client/ledgers/{ledgerId}", ledgerId))
          .andDo(print())
          .andExpect(status().isOk())
          .andExpect(jsonPath("$.status").value("OK"));
    }

    @Test
    @DisplayName("4-2. 다른 사용자의 거래 삭제 시 403 에러가 발생한다")
    @WithMockUser(username = "test@test.com")
    void deleteLedger_AccessDenied() throws Exception {
      // Given
      Long ledgerId = 1L;
      given(ledgerService.deleteLedger(any(AuthDto.class), eq(ledgerId)))
          .willThrow(new CustomException(
              org.springframework.http.HttpStatus.FORBIDDEN,
              "ai.ledger.fail.access_denied",
              "거래에 접근할 수 없습니다."));

      // When & Then
      mockMvc
          .perform(delete("/api/v1/client/ledgers/{ledgerId}", ledgerId))
          .andDo(print())
          .andExpect(status().isForbidden());
    }
  }

  @Nested
  @DisplayName("5. 거래 목록 조회 API 테스트")
  class GetLedgerListApiTests {

    @Test
    @DisplayName("5-1. 거래 목록을 페이징하여 조회할 수 있다")
    @WithMockUser(username = "test@test.com")
    void getLedgerList_Success() throws Exception {
      // Given
      LedgerResponse response1 =
          LedgerResponse.builder()
              .ledgerIdx(1L)
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.of(2024, 1, 15))
              .build();

      LedgerResponse response2 =
          LedgerResponse.builder()
              .ledgerIdx(2L)
              .type(LedgerType.INCOME)
              .amount(new BigDecimal("100000"))
              .desc("월급")
              .category(Category.SUBSCRIPTION)
              .paymentMethod(PaymentMethod.TRANSFER)
              .recordedDate(LocalDate.of(2024, 1, 10))
              .build();

      Pageable pageable = PageRequest.of(0, 10);
      Page<LedgerResponse> page = new PageImpl<>(List.of(response1, response2), pageable, 2);

      doReturn(ResponseEntity.ok(page))
          .when(ledgerService)
          .getLedgerList(any(AuthDto.class), any(LedgerSearchRequest.class), any(Pageable.class));

      // When & Then
      mockMvc
          .perform(get("/api/v1/client/ledgers").param("page", "0").param("size", "10"))
          .andDo(print())
          .andExpect(status().isOk())
          .andExpect(jsonPath("$.status").value("OK"))
          .andExpect(jsonPath("$.content.content").isArray())
          .andExpect(jsonPath("$.content.content[0].desc").value("점심 식사"))
          .andExpect(jsonPath("$.content.content[1].desc").value("월급"))
          .andExpect(jsonPath("$.content.totalElements").value(2));
    }

    @Test
    @DisplayName("5-2. 검색 조건으로 거래 목록을 필터링할 수 있다")
    @WithMockUser(username = "test@test.com")
    void getLedgerList_WithCondition() throws Exception {
      // Given
      LedgerResponse response =
          LedgerResponse.builder()
              .ledgerIdx(1L)
              .type(LedgerType.EXPENSE)
              .amount(new BigDecimal("50000"))
              .desc("점심 식사")
              .category(Category.FOOD)
              .paymentMethod(PaymentMethod.CARD)
              .recordedDate(LocalDate.of(2024, 1, 15))
              .build();

      Pageable pageable = PageRequest.of(0, 10);
      Page<LedgerResponse> page = new PageImpl<>(List.of(response), pageable, 1);

      doReturn(ResponseEntity.ok(page))
          .when(ledgerService)
          .getLedgerList(any(AuthDto.class), any(LedgerSearchRequest.class), any(Pageable.class));

      // When & Then
      mockMvc
          .perform(
              get("/api/v1/client/ledgers")
                  .param("type", "EXPENSE")
                  .param("category", "FOOD")
                  .param("page", "0")
                  .param("size", "10"))
          .andDo(print())
          .andExpect(status().isOk())
          .andExpect(jsonPath("$.status").value("OK"))
          .andExpect(jsonPath("$.content.content").isArray())
          .andExpect(jsonPath("$.content.totalElements").value(1));
    }
  }
}
